// needed for fs ops
import fs from "fs";
import path from "path";

// lodash modules
import isString from "lodash-es/isString";
import uniq from "lodash-es/uniq";

// For typing
import {Argv} from "yargs";
import { CommonExportArguments } from "../types/exportTypes";

// named exports
export const command = "export <command>";
export const description = "Export i18n files into something else";

export const builder = function (y : Argv) {
    return y
        .option("files", {
            describe: "Path to a JSON object that have as key an unique identifier and value the absolute path to a i18n file, such as : { \"FR\": \"/somePath/fr.json\", \"NL\": \"/somePath/nl.json\"}",
            demandOption: true
        })
        .option("filename", {
            type: "string",
            alias: "of",
            describe: "Name of the output file generated by this CLI (without extension)"
        })
        .option("outputDir", {
            type: "string",
            alias: "od",
            describe: "Output folder where to store the output file",
            default: process.cwd()
        })
        // default value for filename
        .default("filename", function() {
            const date = new Date();
            const timestamp = `${date.getDay() + 1}-${date.getMonth() + 1}-${date.getFullYear()} ${date.getHours()}h${date.getMinutes()}m${date.getSeconds()}`;
            return `translations_${timestamp}`;
        })
        .config('settings', function (configPath) {
            return JSON.parse(fs.readFileSync(configPath, 'utf-8'))
        })
        // coerce path provided by outputDir
        .coerce(["outputDir"], path.resolve)
        // convert JSON inline, if present
        .coerce(["files"], (arg) => {
            if (isString(arg)) {
                // arg was passed as string, convert it into a JSON
                return JSON.parse(arg);
            } else {
                // arg was passed as an object thanks to settings
                return arg;
            }
        })
        // validation for filename option
        .check( async (argv) => {
            let filename : unknown = argv["filename"];
            if (path.extname(filename as string).length !== 0) {
                throw new Error(`${filename} has an extension : Remove it please`);
            }
            return true;
        })
        // validation(s) for files option
        .check( async (argv) => {
            let files = argv.files as Object;
            let entries : [String, any][] = Object.entries(files);
            if (entries.length === 0) {
                throw new Error("Option file should have at least one entry");
            }
            if (uniq(Object.values(files)).length !== entries.length) {
                throw new Error(`At least a duplicated value in files JSON object was detected`);
            }
            await Promise.all(
                entries.map(
                    ([_, i18nPath]) => Promise.all([
                        // check if file is a valid file path
                        fs.promises.access(i18nPath),
                        // check if the file is a JSON
                        new Promise((resolve, reject) => {
                            fs.promises
                                .readFile(i18nPath)
                                .then( potentialJSON => {
                                    try {
                                        JSON.parse(potentialJSON.toString());
                                        resolve(undefined);
                                    } catch(_) {
                                        reject(`${i18nPath} isn't a valid JSON`);
                                    }
                                })
                                .catch(err => reject(err))
                        })
                    ])
                )
            )
            // validated
            return true;
        })
        .commandDir("export_cmds", {
            visit(commandModule) {
                return commandModule.default;
            },
            // exclude merge_i18n_files.ts
            exclude: (path) => /merge_i18n_files\.(?:t|j)s/.test(path)
        })
        .help()
        .argv
}
export const handler = function (_ : CommonExportArguments) {};