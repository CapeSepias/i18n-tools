import fs, { PathLike } from "fs";
import path from "path";

// lodash methodes
import isArray from "lodash/isArray";
import isPlainObject from "lodash/isPlainObject";
import isString from "lodash/isString";
import groupBy from "lodash/groupBy";
import uniq from "lodash/uniq";

// For typings
import type { Argv } from "yargs";
import { CommonExportArguments, I18N_Merged_Data } from "../../types/exportTypes"
type I18N_Object = { [x: string]: string | Array<any> | I18N_Object }
type I18N_Result = {
    "technical_key": string,
    "label": string,
    "locale": string
}[]

// middelware
import { parsePathToJSON } from "../../middlewares/middlewares";

// configure export commands with the common options in the builder step
export function setUpCommonsOptions(y: Argv) {
    return y
        .option("files", {
            describe: "Path to a JSON object that have as key an unique identifier and value the absolute path to a i18n file, such as : { \"FR\": \"/somePath/fr.json\", \"NL\": \"/somePath/nl.json\"}",
            demandOption: true
        })
        .option("filename", {
            type: "string",
            alias: "of",
            describe: "Name of the output file generated by this CLI (without extension)"
        })
        .option("outputDir", {
            type: "string",
            alias: "od",
            describe: "Output folder where to store the output file",
            default: process.cwd()
        })
        // default value for filename
        .default("filename", function() {
            const date = new Date();
            const timestamp = `${date.getDay() + 1}-${date.getMonth() + 1}-${date.getFullYear()} ${date.getHours()}h${date.getMinutes()}m${date.getSeconds()}`;
            return `translations_${timestamp}`;
        })
        .config('settings', function (configPath) {
            return JSON.parse(fs.readFileSync(configPath, 'utf-8'))
        })
        // coerce files into Object
        .middleware(parsePathToJSON("files"), true)
        // coerce path provided by outputDir
        .coerce(["outputDir"], path.resolve)
        // validation for filename option
        .check( async (argv) => {
            let filename : unknown = argv["filename"];
            if (path.extname(filename as string).length !== 0) {
                return new Error(`${filename} has an extension : Remove it please`);
            } else {
                return true;
            }
        })
        // validation(s) for files option
        .check( async (argv) => {
            let files = await argv.files as any;
            if (!isPlainObject(files)) {
                return new Error("Option files is not a JSON Object");
            }
            let entries : [String, any][] = Object.entries(files);
            if (entries.length === 0) {
                return new Error("Option files should have at least one entry");
            }
            if (uniq(Object.values(files)).length !== entries.length) {
                return new Error(`At least a duplicated value in files JSON object was detected`);
            }
            await Promise.all(
                entries.map( 
                    entry => verify_files_entry(entry as [string, any])
                )
            ).then(_ => {
                // validated
                return true;
            })
            .catch(err => {
                // failed
                return err;
            });
            return true;
        })
}

// verify if an entry from files option meet requirements
async function verify_files_entry([_, i18nPath] : [string, any]) : Promise<boolean | Error> {
    let potentialJSON;
    // check if file is readable
    try {
        await fs.promises.access(i18nPath);
        potentialJSON = await fs.promises.readFile(i18nPath);
    } catch (error) {
        return Promise.reject(`${i18nPath} cannot be read : check permissions`);
    }
    // check if the file is a JSON
    try {
        JSON.parse(potentialJSON.toString());
        return Promise.resolve(true);
    } catch (error) {
        return Promise.reject(`${i18nPath} isn't a valid JSON`);
    }
}

// turns n i18n file(s) into a merged version
export function merge_i18n_files(argv : CommonExportArguments) : Promise<I18N_Merged_Data> {
    return new Promise( (resolve, reject) => {
        Promise
            // Read files and convert them to useful obj
            .all(
                Object
                    .entries(argv.files)
                    .map(entry => readFile(entry))
            )
            // merge results
            .then(results => mergeResults(results))
            .then(data => resolve(data))
            .catch(err => reject(err));
    });
}

// merge_i18n_files sub functions

// read file and turning into a useful array of objects
function readFile([locale, file_path] : [string, PathLike]) : Promise<I18N_Result> {
    return new Promise((resolve, reject) => {
        fs.promises.readFile(file_path, 'utf8')
            .then(jsonData => Promise.resolve(JSON.parse(jsonData)))
            .then(json => i18n_to_result_format(json, "", locale))
            .then(result => resolve(result))
            .catch(err => reject(err));        
    });
}

// turning a i18n into a useable object for later group by
const flat = (arr: any[]) => [].concat(...arr);

// 
function i18n_to_result_format(obj : I18N_Object, prefix = "", locale = "") : I18N_Result {
    return flat(
        Object
            .keys(obj)
            .map(key => {
                let val = obj[key];
                let technicalKey = `${prefix}.${key}`
                // terminal condition first
                if (isString(val)) {
                    return {"technical_key": technicalKey, "label": val, "locale": locale}
                } else if (isArray(val)) {
                    // hardly ever saw that in a i18n file but better prevent than care
                    return val.map( (item, index) => i18n_to_result_format(item, `${technicalKey}[${index}]`,locale)) 
                } else {
                    return i18n_to_result_format(val, technicalKey, locale);
                }
        })
    );
}

// merge array of {"technical_key": "...", "label": "...", "locale": "..."}
// into {"technical_key": ..., "labels": { "FR": ..., "NL": ..., "DE": ... }}
function mergeResults(results : I18N_Result[]) : Promise<I18N_Merged_Data> {
    let groupBy_technical_key = groupBy(flat(results),Â 'technical_key');

    let final_result = Object
        .keys(groupBy_technical_key)
        .sort()
        .map(key => {
            return {
                "technical_key": key, 
                "labels": groupBy_technical_key[key]
                    .reduce( (prev, curr) => {
                        prev[curr["locale"]] = curr["label"];
                        return prev;
                    }, {})
            }
        });
    return Promise.resolve(final_result);
}