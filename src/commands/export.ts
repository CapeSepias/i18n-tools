// needed for fs ops
import fs from "fs";
import _ from 'lodash';
import path from "path";
import process from 'process';

import {Argv} from "yargs";
import {ExportArguments, I18N_Merged_Data} from "./export/exportTypes";

// named exports
export const command = "export";
export const describe = "Export i18n files into something else";
export const builder = function (y : Argv) {
    return y
        .option("files", {
            description: "JSON object that have as key an unique identifier and value the absolute path to a i18n file, such as : { \"FR\": \"/somePath/fr.json\", \"NL\": \"/somePath/nl.json\"}",
            demandOption: true
        })
        .option("exportColumns", {
            description: "JSON array of objects, to control the export columns. Example : [{ \"locale\": \"FR\", \"label\": \"French translation\" }]",
            demandOption: true
        })
        .option("format", {
            choices: ["xlsx"],
            description: "Format to export the provided i18n files",
            alias: "f",
            default: "xlsx"
        })
        .option("filename", {
            type: "string",
            alias: "of",
            description: "Name of the output file generated by this CLI (without extension)"
        })
        .option("outputDir", {
            type: "string",
            alias: "od",
            description: "Output folder where to store the output file",
            default: process.cwd()
        })
        .option("worksheetName", {
            type: "string",
            description: "Name of the worksheet when format is equal to xlsx",
            default: "Translations"
        })
        .option("worksheetCustomizer", {
            type: "string",
            description: "Path to a JS module to customize the generated xlsx, thanks to exceljs. This js file exports a default function with the following signature : (worksheet : Excel.Worksheet, numberOfRows : number) : "
        })
        // default value for filename
        .default("filename", function() {
            const date = new Date();
            const timestamp = `${date.getDay() + 1}-${date.getMonth() + 1}-${date.getFullYear()} ${date.getHours()}h${date.getMinutes()}m${date.getSeconds()}`;
            return `translations_${timestamp}`;
        })
        .config('settings', function (configPath) {
            return JSON.parse(fs.readFileSync(configPath, 'utf-8'))
        })
        // coerce path provided by outputDir
        .coerce(["outputDir"], path.resolve)
        // convert JSON inline, if present
        .coerce(["files", "exportColumns"], (arg) => {
            if (_.isString(arg)) {
                // arg was passed as string, convert it into a JSON
                return JSON.parse(arg);
            } else {
                // arg was passed as an object thanks to settings
                return arg;
            }
        })
        // validation for filename option
        .check( async (argv) => {
            let filename : unknown = argv["filename"];
            if (path.extname(filename as string).length !== 0) {
                throw new Error(`${filename} has an extension : Remove it please`);
            }
            return true;
        })
        // validation(s) for files option
        .check( async (argv) => {
            let files = argv.files as Object;
            let entries : [String, any][] = Object.entries(files);
            if (entries.length === 0) {
                throw new Error("Option file should have at least one entry");
            }
            if (_.uniq(Object.values(files)).length !== entries.length) {
                throw new Error(`At least a duplicated value in files JSON object was detected`);
            }
            await Promise.all(
                entries.map(
                    ([_, i18nPath]) => Promise.all([
                        // check if file is a valid file path
                        fs.promises.access(i18nPath),
                        // check if the file is a JSON
                        new Promise((resolve, reject) => {
                            fs.promises
                                .readFile(i18nPath)
                                .then( potentialJSON => {
                                    try {
                                        JSON.parse(potentialJSON.toString());
                                        resolve(undefined);
                                    } catch(_) {
                                        reject(`${i18nPath} isn't a valid JSON`);
                                    }
                                })
                                .catch(err => reject(err))
                        })
                    ])
                )
            )
            // validated
            return true;
        })
        // validations for exportColumns option
        .check( (argv) => {
            let exportColumns = argv.exportColumns;
            if (!_.isArray(exportColumns)) {
                throw new Error("exportColumns is not a JSON Array");
            }
            if (exportColumns.length === 0) {
                throw new Error("Option exportColumns should have at least one entry");
            }
            ["locale", "label"].forEach(prop => {
                if (_.some(exportColumns, (item) => !_.has(item, prop) )) {
                    throw new Error(`At least one item in exportColumns array doesn't have "${prop}" property`);
                }
                if (_.some(exportColumns, (item) => !_.isString(_.get(item, prop)) )) {
                    throw new Error(`At least one item in exportColumns array doesn't have "${prop}" property with a String value`);
                }
                if (_.uniq(exportColumns.map( (item : string) => _.get(item, prop))).length !== exportColumns.length) {
                    throw new Error(`At least a duplicated value in exportColumns array in prop "${prop}" was detected`);
                }
            });
            // validated
            return true;
        })
        // validation for both exportColumns & files options
        .check( (argv) => {
            let keys_exportColumns : string[] = argv.exportColumns.map( (x : object) => _.get(x, "locale"));
            let keys_files : string[] = Object.keys(argv.files);
            if (_.difference(keys_exportColumns, keys_files).length !== 0) {
                throw new Error('At least one key differs between files and exportColumns options');
            }
            return true;
        })
        .help()
        .argv;
    }

export const handler = async function (argv : ExportArguments) {
    try {
        let data : I18N_Merged_Data = await require("./export/exportCommon")(argv);
        switch(argv["format"]) {
            case "xlsx":
                await require("./export/exportStrategies/xlsx")(argv, data);
                break;
            default:
                throw new Error(`${argv["format"]} not yet implemented :(`);
        }
    } catch(err) {
        console.error(err);
        process.exit(1);
    }
};

// default export
export default {
    command,
    describe,
    builder,
    handler
}